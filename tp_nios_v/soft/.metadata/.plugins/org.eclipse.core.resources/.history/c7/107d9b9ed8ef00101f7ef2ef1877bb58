#include <stdint.h>
#include <unistd.h>

#include "system.h"
#include "altera_avalon_pio_regs.h"
#include "altera_avalon_i2c.h"

#define ADXL_ADDR 0x53

static ALT_AVALON_I2C_DEV_t *i2c = NULL;

static void adxl_write(uint8_t reg, uint8_t val)
{
    uint8_t tx[2] = { reg, val };
    alt_avalon_i2c_master_target_set(i2c, ADXL_ADDR);
    alt_avalon_i2c_master_tx(i2c, tx, 2, ALT_AVALON_I2C_NO_INTERRUPTS);
}

static void adxl_read_xyz(int16_t *x, int16_t *y, int16_t *z)
{
    uint8_t tx = 0x32; // DATAX0
    uint8_t rx[6];

    alt_avalon_i2c_master_target_set(i2c, ADXL_ADDR);
    alt_avalon_i2c_master_tx_rx(i2c, &tx, 1, rx, 6, ALT_AVALON_I2C_NO_INTERRUPTS);

    *x = (int16_t)((rx[1] << 8) | rx[0]);
    *y = (int16_t)((rx[3] << 8) | rx[2]);
    *z = (int16_t)((rx[5] << 8) | rx[4]);
}

static uint32_t clamp_u32(int v, int lo, int hi)
{
    if (v < lo) v = lo;
    if (v > hi) v = hi;
    return (uint32_t)v;
}

int main(void)
{
    i2c = alt_avalon_i2c_open(I2C_0_NAME);
    if (!i2c) {
        IOWR_ALTERA_AVALON_PIO_DATA(PIO_0_BASE, 0x003);
        while (1);
    }

    // Activer la mesure (POWER_CTL.Measure = 1)
    adxl_write(0x2D, 0x08);

    // “Bulle” sur 10 LEDs : on utilise l’axe X (inclinaison gauche/droite)
    // tu peux changer pour Y si tu préfères.
    while (1)
    {
        int16_t x, y, z;
        adxl_read_xyz(&x, &y, &z);

        // Mapping simple : x ~ [-256..+256] -> index [0..9]
        int idx = (y + 256) * 10 / 512;   // <-- on utilise Y
        idx = (int)clamp_u32(idx, 0, 9);

        uint32_t leds = (1u << idx);

        // Si tes LEDs sont active-low, décommente la ligne suivante :
        // leds = (~leds) & 0x3FF;

        IOWR_ALTERA_AVALON_PIO_DATA(PIO_0_BASE, leds);

        usleep(50000); // 50 ms
    }
}
